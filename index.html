<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>reveal.js – The HTML Presentation Framework</title>

    <meta
      name="description"
      content="A framework for easily creating beautiful presentations using HTML"
    />
    <meta name="author" content="Hakim El Hattab" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/black.css" id="theme" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>

    <!--[if lt IE 9]> <script src="lib/js/html5shiv.js"></script> <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!--
        Any section element inside of this container is displayed as a slide
      -->
      <div class="slides">
        <section>
          <h1>JavaScript Functions</h1>
          <!-- <h3>The Presentation</h3> -->
          <p>
            <small
              >Created by <a href="https://github.com/petriken">petriken</a> and
              <a href="https://github.com/nsubbot">contributors</a></small
            >
          </p>
        </section>

        <section>
          <h2>What is a Function?</h2>

          <ul>
            <li>
              A JavaScript function is a block of code designed to perform a
              particular task.
            </li>
            <li>
              Functions are executed when they are called. 
            </li>
            <li>
              Values can be
              <strong style="text-transform: uppercase; color: #8cd0d3"
                ><em>passed</em></strong
              >
              into functions and used within the function.
            </li>
            <li>
              Functions
              <strong style="text-transform: uppercase; color: #8cd0d3"
                ><em>always</em></strong
              >
              return a value.
            </li>
            <li>
              Functions are
              <strong style="text-transform: uppercase; color: #8cd0d3"
                ><em>objects</em></strong
              >
            </li>
          </ul>
        </section>

        <!-- <h2>Define a Function</h2> -->

        <section>
          <section>
            <h3>define a function</h3>
            <ol>
              <li>
                <strong style="text-transform: uppercase; color: #e3ceab"
                  ><em> Function Declaration</em></strong
                >
              </li>
              <li>
                <strong style="text-transform: uppercase; color: #e3ceab"
                  ><em> Function Expression</em></strong
                >
              </li>
              <li>
                
                <strong style="text-transform: uppercase; color: #e3ceab"
                  ><em> Arrow Function</em></strong
                >
              </li>
            </ol>
          </section>
          <section>
            <h3>Function Declaration</h3>
            <!--
              <p>
              	To create a function declaration you use the function keyword followed by the name of the function
              </p>
            -->
            <!-- <br> -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
						function name(parameter1, parameter2, parameter3) {
						code to be executed
						}
						</code></pre>
            <!--
              <br>
              <p>When using function declarations, the function definition is hoisted, thus allowing the function to be used
              	before it is defined</p>
            -->
          </section>
          <section>
            <h3>Function Expressions</h3>
            <!--
              <p>
              	A Function Expressions defines a named or anonymous function
              </p>
               <br>
            -->
            <p>anonymous function</p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
							let anonymous = function() {
							code to be executed
							}
						</code></pre>
            <br />
            <p>named function</p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
									let named = function name() {
									code to be executed
									}
							</code></pre>
            <!-- <br> -->
            <!--
              <p>Expressions are not hoisted, and therefore cannot be used before they are defined</p>
            -->
          </section>
          <section>
            <h3>Arrow Function</h3>
            <!--
              <p>
              	Arrow functions (also called “fat arrow functions”) are undoubtedly one of the more popular features of ES6.
              </p>
            -->
            <!-- <br> -->
            <span>a function written in ES5 syntax:</span>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
							function timesTwo(parameters) {
							return param * 2
							}
							
							timesTwo(3); // 6
							</code></pre>
            <!-- <br> -->
            <span>the same function written as an arrow function:</span>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
							let timesTwo = parameters => param * 2
										
							timesTwo(3); // 6
							</code></pre>
          </section>
          <section>
            <p>
              Arrow functions does not have its own
              <code style="color: #5eeff7">this, arguments</code>, or
              <code style="color: #5eeff7"> super</code> Arrow function are best
              suited for
              <strong style="text-transform: uppercase; color: #5eeff7">
                non-method functions</strong
              >, and they
              <strong style="text-transform: uppercase; color: #e3ceab">
                cannot be used as constructors</strong
              >.
            </p>
          </section>
          <section>
            <p>Surveys show they’re the most popular ES6 feature:</p>
            <a href="#" class="navigate-down">
              <img
                width="800"
                data-src="./arrow-functions.png"
                alt="arrow-functions"
              />
            </a>
            <small
              >by Dr. Axel Rauschmayer
              <a href="http://2ality.com/2015/07/favorite-es6-features.html"
                >from 2ality.com</a
              ></small
            >
          </section>
        </section>

        <!--
          <section>
          	<h3></h3>
          	<p>According to the airbnb style guide, you must use named function expressions instead of function declarations</p>
          	<pre><code class="hljs" data-trim contenteditable style="font-size: 20px">
          		// bad
          		function foo() {
          		// ...
          		}

          		// bad
          		const foo = function () {
          		// ...
          		};

          		// good
          		// lexical name distinguished from the variable-referenced invocation(s)
          		const short = function longUniqueMoreDescriptiveLexicalFoo() {
          		// ...
          		};
          		</code></pre>
          </section>
        -->

        <!-- Immediately-invoked Function Expression -->

        <section>
          <section>
            <h2>Immediately-invoked Function Expression</h2>
            <!--
              <p>An Immediately-invoked Function Expression (IIFE) is a way to execute functions immediately, as soon as they
              	are created.</p>
            -->
            <p>This is the syntax that defines an IIFE:</p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
									(function() {
									code to be executed
									})()
									</code></pre>
          </section>
          <!--
            <section>
            	<p>We basically have a function defined inside parentheses, and then we append () to execute that function: (/*
            		function */)().</p>
            	<p>You could also put the invoking parentheses inside the expression parentheses, there is no difference, just a
            		styling preference</p>
            	<pre><code class="hljs" data-trim contenteditable style="font-size: 30px">
            					(function() {
            					/* */
            					}())

            					(() => {
            					/* */
            					}())
            					</code></pre>
            </section>
          -->
          <!--
            <section>
            	<p>IIFEs can be defined with arrow functions as well:</p>
            	<pre><code class="hljs" data-trim contenteditable style="font-size: 30px">
            					(() => {
            					code to be executed
            					})()
            					</code></pre>
            	<p>
            		<span style="display: inline-block;" class="fragment fade-up">Also you might see IIFES STARTING WITH A SEMICOLON
            		</span>
            		<pre style="display: inline-block;" class="fragment fade-up"><code class="hljs" data-trim contenteditable style="font-size: 30px">
            									;(function() {
            									/* */
            									})()
            									</code></pre>
            		<span style="display: inline-block;" class="fragment fade-up">This prevents issues when blindly concatenating two
            			JavaScript files</span>
            	</p>
            </section>
          -->
          <!--
            <section>

            </section>
          -->
        </section>

        <section>
          <section>
            <h2>this</h2>
            <p>
              What is
              <strong style="text-transform: uppercase; color: #5eeff7"
                >this</strong
              >
              ? <br />
            </p>
            <!--
                          <p>The JavaScript <strong
               style="color: #5eeff7"> this</strong> keyword refers to the object it belongs to. <br>In most cases, the value
              of <strong style="color: #5eeff7"> this</strong> is determined by how a function is called. It can't be set by
              assignment during execution, and it may be different each time the function is called. </p>
            -->
          </section>
          <section>
            <h3>Global Context</h3>
            <!--
              <p>In the global execution context (outside of any function), <strong style="color: #5eeff7"> this</strong> refers
              	to the global object whether in strict mode or not.</p>
            -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
			// In web browsers, the window object is also 
			// the global object:
			console.log(this === window); // true
			
			a = 37;
			console.log(window.a); // 37
			
			this.b = "MDN";
			console.log(window.b) // "MDN"
			console.log(b) // "MDN"

			</code></pre>
          </section>
          <section>
            <h3>Function context</h3>
            <p style="font-size: 30px">
              Inside a function, the value of
              <strong style="color: #5eeff7"> this</strong> depends on how the
              function is called.
            </p>
            <!--
              <h4>Simple call</h4>
              <p style="font-size: 30px">Since the following code is not in <strong style="color: #5eeff7"> strict mode</strong>,
              	and because the value of this is not set by the call, <strong style="color: #5eeff7"> this</strong> will default
              	to the global object, which is window in a browser. </p>
            -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 24px">	
					function f1() {
					return this;
					}
					// In a browser:
					f1() === window; // true
					// In Node:
					f1() === global; // true
					
				</code></pre>
            <!--
              <p style="font-size: 30px">In <strong style="color: #5eeff7"> strict mode</strong>, however, the value of <strong
              	 style="color: #5eeff7"> this</strong> remains at whatever it was set to when entering the execution context, so,
              	in the following case, <strong style="color: #5eeff7"> this</strong> will default to <strong style="color: #5eeff7">
              		undefined</strong></p>
            -->
          </section>
          <section>
            <p>
              <strong style="color: #5eeff7"> call()</strong>,
              <strong style="color: #5eeff7"> apply()</strong>:
            </p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
					// An object can be passed as the first argument
					// to call or apply and this will be bound to it.
					const obj = {a: 'Custom'};
					// This property is set on the global object
					const a = 'Global';
					
					function whatsThis() {
					return this.a; // The value of this is dependent
					// on how the function is called
					}
					
					whatsThis(); // 'Global'
					whatsThis.call(obj); // 'Custom'
					whatsThis.apply(obj); // 'Custom'
	
				</code></pre>
          </section>
          <!--
            	<section>
            		<p style="font-size: 30px">ECMAScript 5 introduced method .bind() <br>Calling <strong style="color: #5eeff7">
            				f.bind(someObject)</strong> creates a new function with the same body and scope as f, but where <strong style="color: #5eeff7">
            				this</strong> occurs in the original function, in the new function it is permanently bound to the first argument
            			of <strong style="color: #5eeff7"> bind</strong>, regardless of how the function is being used</p>
            		<pre><code class="hljs" data-trim contenteditable style="font-size: 30px">
            	function f() {
            	return this.a;
            	}

            	let g = f.bind({a: 'azerty'});
            	console.log(g()); // azerty

            	let h = g.bind({a: 'yoo'}); //bind only works once!
            	console.log(h()); // azerty

            	let o = {a: 37, f: f, g: g, h: h};
            	console.log(o.a, o.f(), o.g(), o.h()); // 37,37,
            	// azerty, azerty

            </code></pre>
            	</section>
          -->
          <section>
            <h4>arrow functions</h4>
            <!-- <p>
              In
              <strong style="text-transform: uppercase; color: #e3ceab">
                arrow functions</strong
              >, <strong style="color: #5eeff7"> this</strong> retains the value
              of the enclosing lexical context's
              <strong style="color: #5eeff7"> this</strong>. In global code, it
              will be set to the global object:
            </p> -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
				let globalObject = this;
				let foo = (() => this);
				console.log(foo() === globalObject); // true
			</code></pre>
            <!--
              <p>No matter what, foo's <strong style="color: #5eeff7"> this</strong> is set to what it was when it was
              	created.The same applies to arrow functions created inside other functions: their <strong style="color: #5eeff7">
              		this</strong> remains that of the enclosing lexical context.
              </p>
            -->
          </section>
          <section>
            <h4>As an object method</h4>
            <!--
              <p>When a function is called as a method of an object, its <strong style="color: #5eeff7"> this</strong> is set to
              	the object the method is called on.
              	Note that <strong style="color: #5eeff7"> this</strong> behavior is not at all affected by how or where the
              	function was defined
              </p>
            -->
            <h4>As a constructord</h4>
            <!--
              <p>When a function is used as a constructor (with the <strong style="color: #5eeff7"> new</strong> keyword), its
              	<strong style="color: #5eeff7"> this</strong> is bound to the new object being constructed
              </p>
            -->
            <!--
              </section>
              <section>
            -->
            <h4>As a DOM event handler</h4>
            <!--
              <p>When a function is used as an event handler, its <strong style="color: #5eeff7"> this</strong> is set to the element the event fired from (some browsers
              	do not follow this convention for listeners added dynamically with methods other than <strong style="color: #5eeff7"> addEventListener()</strong>)</p>
            -->
            <!--
              </section>
              <section>
            -->
            <h4>In an inline event handler</h4>
            <!--
              <p>When the code is called from an inline on-event handler, its <strong style="color: #5eeff7"> this</strong> is set to the DOM element on which the
              	listener is placed:</p>
            -->
            <!--
              <pre><code class="hljs" data-trim contenteditable style="font-size: 28px">
              	<button onclick="alert(this.tagName.toLowerCase());">
              		Show this
              	</button>
              </code></pre>
              <p>The above alert shows button. Note however that only the outer code has its <strong style="color: #5eeff7"> this</strong> set this way</p>
            -->
          </section>
        </section>

        <!-- Closure -->

        <section>
          <section>
            <h3>Closure</h3>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
						function makeFunc() {
						let name = 'Godzilla';
						function displayName() {
						alert(name);
						}
						return displayName;
						}
						
						let myFunc = makeFunc();
						myFunc();
						</code></pre>
            <!--
              <p>A closure is the combination of a function and the lexical environment within which that function was declared</p>
            -->
          </section>
          <!--
            <section>
            	<pre><code class="hljs" data-trim contenteditable style="font-size: 30px">
            			function makeAdder(x) {
            			return function(y) {
            			return x + y;
            			};
            			}

            			const add5 = makeAdder(5);
            			const add10 = makeAdder(10);

            			console.log(add5(2)); // 7
            			console.log(add10(2)); // 12
            			</code></pre>
            	<p>A closure is the combination of a function and the lexical environment within which that function was declared</p>
            </section>
          -->
          <section>
            <h3>Practical closures</h3>
            <!--
              <p style="font-size: 30px">Closures are useful because they let you associate some data (the lexical environment)
              	with a function that operates on that data</p>
              <h4>Emulating private methods with closures</h4>
              <ul>
              	<li style="font-size: 30px">JavaScript does not provide a native way to declare methods private, but it is
              		possible to emulate private methods using closures. Private methods aren't just useful for restricting access to
              		code: they also provide a powerful way of managing your global namespace, keeping non-essential methods from
              		cluttering up the public interface to your code</li>
              	<li style="font-size: 30px">Also we can use closures to define public functions that can access private functions
              		and variables</li>
              </ul>
              <h4>Performance considerations</h4>
              <p style="font-size: 30px"> It is unwise to unnecessarily create functions within other functions if closures are
              	not needed for a particular task, as it will negatively affect script performance both in terms of processing
              	speed and memory consumption</p>
            -->
          </section>
        </section>

        <!-- function composition -->
        <section>
          <section>
            <h3>function composition</h3>
            <!--
              <p>Is a mechanism of combining multiple simple functions to build a more complicated one. The result of each
              	function is passed to the next one until you get a result</p>
            -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
						function compose(f1, f2) {
						return function(value) {
						return f1(f2(value));
						};
						}
						</code></pre>
            <span> or as an arrow function</span>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 30px">	
										() => () => result;
										</code></pre>
          </section>
          <!--
            <section>
            	<p>Compose has a twin. It’s often called <strong style="text-transform: uppercase; color: #8cd0d3">pipe</strong></p>
            	<pre><code class="hljs" data-trim contenteditable style="font-size: 30px">
            			const pipe = (fn,...fns) => (...args) => ...magic...;
            			//use the spread operator, ...fns, to apply all the
            			//arguments to compose to pipe, but backwards
            			const compose = (...fns) => pipe(...fns.reverse());

            			</code></pre>

            </section>
          -->
        </section>
        <!-- Method Chaining -->
        <section>
          <section>
            <h3>Method Chaining</h3>
            <!--
              <p style="font-size: 40px">Method chaining is a technique that can be used to simplify code in scenarios that
              	involve calling multiple functions on the same object consecutively. <br>The typical way to enable method
              	chaining is to return the current object at the end of every function.</p>
            -->
            <!--
              </section>
              <section>
            -->
            <!--
              <h4>
              	Implementing Method Chaining
              </h4>
              <p style="font-size: 30px">For our example, we will define a custom class with the ability to chain methods</p>
            -->
            <pre><code class="hljs" data-trim contenteditable style="font-size: 20px">	
				
const Kitten = function() {
this.name = 'Garfield';
this.color = 'brown';
this.gender = 'male';
};

Kitten.prototype.setName = function(name) {
this.name = name;
return this;
};

Kitten.prototype.setColor = function(color) {
this.color = color;
return this;
};

Kitten.prototype.setGender = function(gender) {
this.gender = gender;
return this;
};

Kitten.prototype.save = function() {
console.log(
'saving ' + this.name + ', the ' +
this.color + ' ' + this.gender + ' kitten...'
);

return this;
};

					</code></pre>
          </section>
          <section>
            <p style="font-size: 30px">
              Here is example with method chaining on our new class:
            </p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 20px">
					new Kitten()
					.setName('Bob')
					.setColor('black')
					.setGender('male')
					.save();
					
					// > saving Bob, the black male kitten...
				</code></pre>
            <p style="font-size: 30px">
              Here is example without method chaining on our new class:
            </p>
            <pre><code class="hljs" data-trim contenteditable style="font-size: 20px">
					const bob = new Kitten();
					
					bob.setName('Bob');
					bob.setColor('black');
					bob.setGender('male');
					
					bob.save();
					
					// > saving Bob, the black male kitten...
				</code></pre>
          </section>
          <!--
            <section>
            	<p>By using method chaining we end up with much cleaner code that is easier to understand. <br> Method chaining
            		can be a very useful technique to have in your bag of programming tools</p>
            </section>
          -->
        </section>

        <!-- всплытие снизу -->

        <!-- style="display: inline-block;" class="fragment fade-up" -->

        <!-- Example of nested vertical slides -->
        <section>
          <!--
            <h3>talk about the functions of javascript can be infinite, so this will end.</h3>
          -->
          <h3>Thanks for attention</h3>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: "slide", // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          {
            src: "lib/js/classList.js",
            condition: function() {
              return !document.body.classList;
            }
          },
          {
            src: "plugin/markdown/marked.js",
            condition: function() {
              return !!document.querySelector("[data-markdown]");
            }
          },
          {
            src: "plugin/markdown/markdown.js",
            condition: function() {
              return !!document.querySelector("[data-markdown]");
            }
          },
          {
            src: "plugin/highlight/highlight.js",
            async: true,
            callback: function() {
              hljs.initHighlightingOnLoad();
            }
          },
          { src: "plugin/search/search.js", async: true },
          { src: "plugin/zoom-js/zoom.js", async: true },
          { src: "plugin/notes/notes.js", async: true }
        ]
      });
    </script>
  </body>
</html>
